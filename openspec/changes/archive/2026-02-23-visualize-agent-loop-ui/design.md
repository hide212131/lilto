## Context

現行実装は Main でエージェント実行を完了まで待ち、Renderer には最終 `promptResult` のみを返すため、ユーザーは処理中の進行状況を観測できない。`pi-agent-core` 自体は `tool_execution_start/end` やメッセージストリームをイベントとして提供しており、`pi-web-ui` では購読して UI を更新している。

本変更は以下の制約下で進める。
- 既存の Main 実行経路（SDK 直接実行）を維持する
- 既存メッセージ履歴モデルとの互換性を保つ
- GUI 変更として Electron E2E で検証する

## Goals / Non-Goals

**Goals:**
- 実行中ループの状態（思考/ツール実行/完了/失敗）を Renderer でリアルタイム表示する。
- Main->Renderer のイベントチャネルを定義し、UI 更新をイベント駆動にする。
- 既存の最終応答表示を壊さず、可視化情報を追加で提供する。
- `pi-web-ui` の連携方式を参照し、将来的な追従がしやすい構造にする。

**Non-Goals:**
- `pi-web-ui` の全 UI コンポーネントを wholesale で移植しない。
- ツール結果の詳細レンダラー（artifact 表示など）をこの変更で完全再現しない。
- セッション永続化方式や認証フローを再設計しない。

## Decisions

### 1) Main でエージェントイベントを正規化し、専用 IPC で逐次通知する
- 決定: Main で `pi-agent-core` のイベントを購読し、UI向け `loop-event` 形式へ正規化して `onAgentLoopEvent` で Renderer に push する。
- 理由: Renderer から Main の内部状態へ直接アクセスせず、責務分離を保てる。最終結果 API を維持したまま段階導入できる。
- 代替案A: Renderer で直接 agent を実行する。
  - 却下理由: 認証情報・実行権限が Main 側にあり、既存アーキテクチャと衝突する。
- 代替案B: 最終結果 API のポーリングで擬似進捗を出す。
  - 却下理由: 実際のツール実行情報が取れず、可視化の精度が不足する。

### 2) Renderer は「一時ループ状態」と「確定メッセージ」を分離管理する
- 決定: 既存 `messages` は確定履歴として保持し、実行中表示は別 state（`loopState`）で管理する。
- 理由: ストリーミング途中データを履歴に混在させると整合性が崩れやすい。完了時に必要分だけ確定履歴へ反映する方が安全。
- 代替案A: 進行中イベントを直接 `messages` へ append する。
  - 却下理由: リトライ/中断時の巻き戻しが難しく、UI のちらつきと重複表示を起こしやすい。

### 3) 可視化 UI は最小セット（実行中バナー + アクティブツール一覧）で開始する
- 決定: 初期ポーティングは、上部ステータス（思考中/ツール実行中/完了/失敗）と現在実行中ツール一覧に限定する。
- 理由: 価値の高い情報を短期間で提供でき、既存 UI への影響を最小化できる。
- 代替案A: `pi-web-ui` の全ツールレンダラーを同時移植する。
  - 却下理由: 変更範囲が大きく、今回の目的（ループ可視化）を超過する。

### 4) テストは Main 単体 + Renderer 単体 + Electron E2E の3層で担保する
- 決定: Main はイベント正規化、Renderer は state 遷移、E2E は実行中表示の視認を検証する。
- 理由: 層ごとに故障点を分離でき、回帰時の原因特定が速い。

## Risks / Trade-offs

- [イベント頻度増加で Renderer 描画負荷が上がる] → 連続イベントは最小単位に正規化し、必要に応じて UI 更新をバッチ化する。
- [Main/Renderer のイベント契約が将来の SDK 変更でずれる] → 型定義を共有化し、未知イベントは安全に無視できるフォールバックを持つ。
- [実行中 state のクリア漏れで表示が残留する] → `agent_end` / エラー経路で共通 cleanup を必須化し、単体テストで確認する。

## Migration Plan

1. Main にループイベント購読と IPC push を追加する（既存 `promptResult` は維持）。
2. Preload に `onAgentLoopEvent` を追加し、Renderer へ購読 API を公開する。
3. Renderer に `loopState` と可視化 UI を追加する。
4. 単体テストと Electron E2E を更新し、可視化要件を検証する。
5. 問題時は `onAgentLoopEvent` 購読と UI 表示を feature flag で無効化し、最終結果表示のみへロールバック可能にする。

## Open Questions

- `thinking_*` イベントを初期スコープに含めるか、ツール実行イベントのみを先行実装するか。
- 可視化対象を「現在実行中のみ」にするか、「直近履歴（完了済み数件）」まで出すか。
